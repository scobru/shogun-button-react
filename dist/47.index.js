/*! For license information please see 47.index.js.LICENSE.txt */
"use strict";(this.webpackChunkShogunButtonReact=this.webpackChunkShogunButtonReact||[]).push([[47],{91047:(e,t,f)=>{f.d(t,{p256:()=>P,p384:()=>k,p521:()=>q});var r=f(8442),n=f(21454),o=f(32531),i=f(78906),s=f(50649),a=f(15916);const c=(e,t)=>(e+(e>=0?t:-t)/m)/t;function d(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function u(e,t){const f={};for(let r of Object.keys(t))f[r]=void 0===e[r]?t[r]:e[r];return(0,i.d6)(f.lowS,"lowS"),(0,i.d6)(f.prehash,"prehash"),void 0!==f.format&&d(f.format),f}class l extends Error{constructor(e=""){super(e)}}const h={Err:l,_tlv:{encode:(e,t)=>{const{Err:f}=h;if(e<0||e>256)throw new f("tlv.encode: wrong tag");if(1&t.length)throw new f("tlv.encode: unpadded data");const r=t.length/2,n=(0,i.zW)(r);if(n.length/2&128)throw new f("tlv.encode: long form length too big");const o=r>127?(0,i.zW)(n.length/2|128):"";return(0,i.zW)(e)+o+n+t},decode(e,t){const{Err:f}=h;let r=0;if(e<0||e>256)throw new f("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new f("tlv.decode: wrong tlv");const n=t[r++];let o=0;if(128&n){const e=127&n;if(!e)throw new f("tlv.decode(long): indefinite length not supported");if(e>4)throw new f("tlv.decode(long): byte length is too big");const i=t.subarray(r,r+e);if(i.length!==e)throw new f("tlv.decode: length bytes not complete");if(0===i[0])throw new f("tlv.decode(long): zero leftmost byte");for(const e of i)o=o<<8|e;if(r+=e,o<128)throw new f("tlv.decode(long): not minimal encoding")}else o=n;const i=t.subarray(r,r+o);if(i.length!==o)throw new f("tlv.decode: wrong value length");return{v:i,l:t.subarray(r+o)}}},_int:{encode(e){const{Err:t}=h;if(e<y)throw new t("integer: negative integers are not allowed");let f=(0,i.zW)(e);if(8&Number.parseInt(f[0],16)&&(f="00"+f),1&f.length)throw new t("unexpected DER parsing assertion: unpadded hex");return f},decode(e){const{Err:t}=h;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return(0,i.Ph)(e)}},toSig(e){const{Err:t,_int:f,_tlv:r}=h,n=(0,i.qj)("signature",e),{v:o,l:s}=r.decode(48,n);if(s.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,o),{v:d,l:u}=r.decode(2,c);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:f.decode(a),s:f.decode(d)}},hexFromSig(e){const{_tlv:t,_int:f}=h,r=t.encode(2,f.encode(e.r))+t.encode(2,f.encode(e.s));return t.encode(48,r)}},y=BigInt(0),b=BigInt(1),m=BigInt(2),p=BigInt(3),g=BigInt(4);function w(e,t){const{BYTES:f}=e;let r;if("bigint"==typeof t)r=t;else{let n=(0,i.qj)("private key",t);try{r=e.fromBytes(n)}catch(e){throw new Error(`invalid private key: expected ui8a of size ${f}, got ${typeof t}`)}}if(!e.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function E(e){return Uint8Array.of(e?2:3)}function B(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function v(e){const{CURVE:t,curveOpts:f,hash:r,ecdsaOpts:l}=function(e){const{CURVE:t,curveOpts:f}=function(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},f=e.Fp;let r=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(e=>Math.ceil(e/2)))):void 0;return{CURVE:t,curveOpts:{Fp:f,Fn:(0,a.D0)(t.n,{BITS:e.nBitLength,allowedLengths:r,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes}}}(e),r={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:f,hash:e.hash,ecdsaOpts:r}}(e);return function(e,t){const f=t.Point;return Object.assign({},t,{ProjectivePoint:f,CURVE:Object.assign({},e,(0,a.LH)(f.Fn.ORDER,f.Fn.BITS))})}(e,function(e,t,f={}){(0,o.sd)(t),(0,i.DS)(f,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=f.randomBytes||o.po,s=f.hmac||((e,...f)=>(0,n.w)(t,e,(0,o.Id)(...f))),{Fp:c,Fn:l}=e,{ORDER:p,BITS:g}=l,{keygen:v,getPublicKey:x,getSharedSecret:S,utils:O,lengths:R}=function(e,t={}){const{Fn:f}=e,r=t.randomBytes||o.po,n=Object.assign(B(e.Fp,f),{seed:(0,a.Tp)(f.ORDER)});function s(e){try{return!!w(f,e)}catch(e){return!1}}function c(e=r(n.seed)){return(0,a.qy)((0,i.eV)(e,n.seed,"seed"),f.ORDER)}function d(t,r=!0){return e.BASE.multiply(w(f,t)).toBytes(r)}function u(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const{secretKey:r,publicKey:o,publicKeyUncompressed:s}=n;if(f.allowedLengths||r===o)return;const a=(0,i.qj)("key",t).length;return a===o||a===s}const l={isValidSecretKey:s,isValidPublicKey:function(t,f){const{publicKey:r,publicKeyUncompressed:o}=n;try{const n=t.length;return!(!0===f&&n!==r||!1===f&&n!==o||!e.fromBytes(t))}catch(e){return!1}},randomSecretKey:c,isValidPrivateKey:s,randomPrivateKey:c,normPrivateKeyToScalar:e=>w(f,e),precompute:(t=8,f=e.BASE)=>f.precompute(t,!1)};return Object.freeze({getPublicKey:d,getSharedSecret:function(t,r,n=!0){if(!0===u(t))throw new Error("first arg must be private key");if(!1===u(r))throw new Error("second arg must be public key");const o=w(f,t);return e.fromHex(r).multiply(o).toBytes(n)},keygen:function(e){const t=c(e);return{secretKey:t,publicKey:d(t)}},Point:e,utils:l,lengths:n})}(e,f),I={prehash:!1,lowS:"boolean"==typeof f.lowS&&f.lowS,format:void 0,extraEntropy:!1},K="compact";function V(e){return e>p>>b}function P(e,t){if(!l.isValidNot0(t))throw new Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class k{constructor(e,t,f){this.r=P("r",e),this.s=P("s",t),null!=f&&(this.recovery=f),Object.freeze(this)}static fromBytes(e,t=K){let f;if(function(e,t){d(t);const f=R.signature,r="compact"===t?f:"recovered"===t?f+1:void 0;(0,i.eV)(e,r,`${t} signature`)}(e,t),"der"===t){const{r:t,s:f}=h.toSig((0,i.eV)(e));return new k(t,f)}"recovered"===t&&(f=e[0],t="compact",e=e.subarray(1));const r=l.BYTES,n=e.subarray(0,r),o=e.subarray(r,2*r);return new k(l.fromBytes(n),l.fromBytes(o),f)}static fromHex(e,t){return this.fromBytes((0,o.aT)(e),t)}addRecoveryBit(e){return new k(this.r,this.s,e)}recoverPublicKey(t){const f=c.ORDER,{r,s:n,recovery:s}=this;if(null==s||![0,1,2,3].includes(s))throw new Error("recovery id invalid");if(p*m<f&&s>1)throw new Error("recovery id is ambiguous for h>1 curve");const a=2===s||3===s?r+p:r;if(!c.isValid(a))throw new Error("recovery id 2 or 3 invalid");const d=c.toBytes(a),u=e.fromBytes((0,o.Id)(E(!(1&s)),d)),h=l.inv(a),y=A((0,i.qj)("msgHash",t)),b=l.create(-y*h),g=l.create(n*h),w=e.BASE.multiplyUnsafe(b).add(u.multiplyUnsafe(g));if(w.is0())throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return V(this.s)}toBytes(e=K){if(d(e),"der"===e)return(0,o.aT)(h.hexFromSig(this));const t=l.toBytes(this.r),f=l.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw new Error("recovery bit must be present");return(0,o.Id)(Uint8Array.of(this.recovery),t,f)}return(0,o.Id)(t,f)}toHex(e){return(0,o.My)(this.toBytes(e))}assertValidity(){}static fromCompact(e){return k.fromBytes((0,i.qj)("sig",e),"compact")}static fromDER(e){return k.fromBytes((0,i.qj)("sig",e),"der")}normalizeS(){return this.hasHighS()?new k(this.r,l.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,o.My)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,o.My)(this.toBytes("compact"))}}const q=f.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=(0,i.Ph)(e),f=8*e.length-g;return f>0?t>>BigInt(f):t},A=f.bits2int_modN||function(e){return l.create(q(e))},F=(0,i.OG)(g);function Z(e){return(0,i.aK)("num < 2^"+g,e,y,F),l.toBytes(e)}function j(e,f){return(0,i.eV)(e,void 0,"message"),f?(0,i.eV)(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:v,getPublicKey:x,getSharedSecret:S,utils:O,lengths:R,Point:e,sign:function(f,n,a={}){f=(0,i.qj)("message",f);const{seed:c,k2sig:d}=function(t,f,n){if(["recovered","canonical"].some(e=>e in n))throw new Error("sign() legacy options not supported");const{lowS:s,prehash:a,extraEntropy:c}=u(n,I);t=j(t,a);const d=A(t),h=w(l,f),m=[Z(h),Z(d)];if(null!=c&&!1!==c){const e=!0===c?r(R.secretKey):c;m.push((0,i.qj)("extraEntropy",e))}const p=(0,o.Id)(...m),g=d;return{seed:p,k2sig:function(t){const f=q(t);if(!l.isValidNot0(f))return;const r=l.inv(f),n=e.BASE.multiply(f).toAffine(),o=l.create(n.x);if(o===y)return;const i=l.create(r*l.create(g+o*h));if(i===y)return;let a=(n.x===o?0:2)|Number(n.y&b),c=i;return s&&V(i)&&(c=l.neg(i),a^=1),new k(o,c,a)}}}(f,n,a);return(0,i.fg)(t.outputLen,l.BYTES,s)(c,d)},verify:function(t,f,r,n={}){const{lowS:s,prehash:a,format:c}=u(n,I);if(r=(0,i.qj)("publicKey",r),f=j((0,i.qj)("message",f),a),"strict"in n)throw new Error("options.strict was renamed to lowS");const d=void 0===c?function(e){let t;const f="string"==typeof e||(0,o.aY)(e),r=!f&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!f&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(r)t=new k(e.r,e.s);else if(f){try{t=k.fromBytes((0,i.qj)("sig",e),"der")}catch(e){if(!(e instanceof h.Err))throw e}if(!t)try{t=k.fromBytes((0,i.qj)("sig",e),"compact")}catch(e){return!1}}return t||!1}(t):k.fromBytes((0,i.qj)("sig",t),c);if(!1===d)return!1;try{const t=e.fromBytes(r);if(s&&d.hasHighS())return!1;const{r:n,s:o}=d,i=A(f),a=l.inv(o),c=l.create(i*a),u=l.create(n*a),h=e.BASE.multiplyUnsafe(c).add(t.multiplyUnsafe(u));return!h.is0()&&l.create(h.x)===n}catch(e){return!1}},recoverPublicKey:function(e,t,f={}){const{prehash:r}=u(f,I);return t=j(t,r),k.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:k,hash:t})}(function(e,t={}){const f=(0,s.UT)("weierstrass",e,t),{Fp:r,Fn:n}=f;let a=f.CURVE;const{h:d,n:u}=a;(0,i.DS)(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:l}=t;if(l&&(!r.is0(a.a)||"bigint"!=typeof l.beta||!Array.isArray(l.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const h=B(r,n);function m(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const v=t.toBytes||function(e,t,f){const{x:n,y:s}=t.toAffine(),a=r.toBytes(n);if((0,i.d6)(f,"isCompressed"),f){m();const e=!r.isOdd(s);return(0,o.Id)(E(e),a)}return(0,o.Id)(Uint8Array.of(4),a,r.toBytes(s))},x=t.fromBytes||function(e){(0,i.eV)(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:f}=h,n=e.length,o=e[0],s=e.subarray(1);if(n!==t||2!==o&&3!==o){if(n===f&&4===o){const e=r.BYTES,t=r.fromBytes(s.subarray(0,e)),f=r.fromBytes(s.subarray(e,2*e));if(!O(t,f))throw new Error("bad point: is not on curve");return{x:t,y:f}}throw new Error(`bad point: got length ${n}, expected compressed=${t} or uncompressed=${f}`)}{const e=r.fromBytes(s);if(!r.isValid(e))throw new Error("bad point: is not on curve, wrong x");const t=S(e);let f;try{f=r.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("bad point: is not on curve, sqrt error"+t)}return m(),!(1&~o)!==r.isOdd(f)&&(f=r.neg(f)),{x:e,y:f}}};function S(e){const t=r.sqr(e),f=r.mul(t,e);return r.add(r.add(f,r.mul(e,a.a)),a.b)}function O(e,t){const f=r.sqr(t),n=S(e);return r.eql(f,n)}if(!O(a.Gx,a.Gy))throw new Error("bad curve params: generator point");const R=r.mul(r.pow(a.a,p),g),I=r.mul(r.sqr(a.b),BigInt(27));if(r.is0(r.add(R,I)))throw new Error("bad curve params: a or b");function K(e,t,f=!1){if(!r.isValid(t)||f&&r.is0(t))throw new Error(`bad point coordinate ${e}`);return t}function V(e){if(!(e instanceof F))throw new Error("ProjectivePoint expected")}function P(e){if(!l||!l.basises)throw new Error("no endo");return function(e,t,f){const[[r,n],[o,s]]=t,a=c(s*e,f),d=c(-n*e,f);let u=e-a*r-d*o,l=-a*n-d*s;const h=u<y,m=l<y;h&&(u=-u),m&&(l=-l);const p=(0,i.OG)(Math.ceil((0,i.dJ)(f)/2))+b;if(u<y||u>=p||l<y||l>=p)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:h,k1:u,k2neg:m,k2:l}}(e,l.basises,n.ORDER)}const k=(0,i.x)((e,t)=>{const{X:f,Y:n,Z:o}=e;if(r.eql(o,r.ONE))return{x:f,y:n};const i=e.is0();null==t&&(t=i?r.ONE:r.inv(o));const s=r.mul(f,t),a=r.mul(n,t),c=r.mul(o,t);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}),q=(0,i.x)(e=>{if(e.is0()){if(t.allowInfinityPoint&&!r.is0(e.Y))return;throw new Error("bad point: ZERO")}const{x:f,y:n}=e.toAffine();if(!r.isValid(f)||!r.isValid(n))throw new Error("bad point: x or y not field elements");if(!O(f,n))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function A(e,t,f,n,o){return f=new F(r.mul(f.X,e),f.Y,f.Z),t=(0,s.u0)(n,t),f=(0,s.u0)(o,f),t.add(f)}class F{constructor(e,t,f){this.X=K("x",e),this.Y=K("y",t,!0),this.Z=K("z",f),Object.freeze(this)}static CURVE(){return a}static fromAffine(e){const{x:t,y:f}=e||{};if(!e||!r.isValid(t)||!r.isValid(f))throw new Error("invalid affine point");if(e instanceof F)throw new Error("projective point not allowed");return r.is0(t)&&r.is0(f)?F.ZERO:new F(t,f,r.ONE)}static fromBytes(e){const t=F.fromAffine(x((0,i.eV)(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return F.fromBytes((0,i.qj)("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return j.createCache(this,e),t||this.multiply(p),this}assertValidity(){q(this)}hasEvenY(){const{y:e}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(e)}equals(e){V(e);const{X:t,Y:f,Z:n}=this,{X:o,Y:i,Z:s}=e,a=r.eql(r.mul(t,s),r.mul(o,n)),c=r.eql(r.mul(f,s),r.mul(i,n));return a&&c}negate(){return new F(this.X,r.neg(this.Y),this.Z)}double(){const{a:e,b:t}=a,f=r.mul(t,p),{X:n,Y:o,Z:i}=this;let s=r.ZERO,c=r.ZERO,d=r.ZERO,u=r.mul(n,n),l=r.mul(o,o),h=r.mul(i,i),y=r.mul(n,o);return y=r.add(y,y),d=r.mul(n,i),d=r.add(d,d),s=r.mul(e,d),c=r.mul(f,h),c=r.add(s,c),s=r.sub(l,c),c=r.add(l,c),c=r.mul(s,c),s=r.mul(y,s),d=r.mul(f,d),h=r.mul(e,h),y=r.sub(u,h),y=r.mul(e,y),y=r.add(y,d),d=r.add(u,u),u=r.add(d,u),u=r.add(u,h),u=r.mul(u,y),c=r.add(c,u),h=r.mul(o,i),h=r.add(h,h),u=r.mul(h,y),s=r.sub(s,u),d=r.mul(h,l),d=r.add(d,d),d=r.add(d,d),new F(s,c,d)}add(e){V(e);const{X:t,Y:f,Z:n}=this,{X:o,Y:i,Z:s}=e;let c=r.ZERO,d=r.ZERO,u=r.ZERO;const l=a.a,h=r.mul(a.b,p);let y=r.mul(t,o),b=r.mul(f,i),m=r.mul(n,s),g=r.add(t,f),w=r.add(o,i);g=r.mul(g,w),w=r.add(y,b),g=r.sub(g,w),w=r.add(t,n);let E=r.add(o,s);return w=r.mul(w,E),E=r.add(y,m),w=r.sub(w,E),E=r.add(f,n),c=r.add(i,s),E=r.mul(E,c),c=r.add(b,m),E=r.sub(E,c),u=r.mul(l,w),c=r.mul(h,m),u=r.add(c,u),c=r.sub(b,u),u=r.add(b,u),d=r.mul(c,u),b=r.add(y,y),b=r.add(b,y),m=r.mul(l,m),w=r.mul(h,w),b=r.add(b,m),m=r.sub(y,m),m=r.mul(l,m),w=r.add(w,m),y=r.mul(b,w),d=r.add(d,y),y=r.mul(E,w),c=r.mul(g,c),c=r.sub(c,y),y=r.mul(g,b),u=r.mul(E,u),u=r.add(u,y),new F(c,d,u)}subtract(e){return this.add(e.negate())}is0(){return this.equals(F.ZERO)}multiply(e){const{endo:f}=t;if(!n.isValidNot0(e))throw new Error("invalid scalar: out of range");let r,o;const i=e=>j.cached(this,e,e=>(0,s.Ak)(F,e));if(f){const{k1neg:t,k1:n,k2neg:s,k2:a}=P(e),{p:c,f:d}=i(n),{p:u,f:l}=i(a);o=d.add(l),r=A(f.beta,c,u,t,s)}else{const{p:t,f}=i(e);r=t,o=f}return(0,s.Ak)(F,[r,o])[0]}multiplyUnsafe(e){const{endo:f}=t,r=this;if(!n.isValid(e))throw new Error("invalid scalar: out of range");if(e===y||r.is0())return F.ZERO;if(e===b)return r;if(j.hasCache(this))return this.multiply(e);if(f){const{k1neg:t,k1:n,k2neg:o,k2:i}=P(e),{p1:a,p2:c}=(0,s.fH)(F,r,n,i);return A(f.beta,a,c,t,o)}return j.unsafe(r,e)}multiplyAndAddUnsafe(e,t,f){const r=this.multiplyUnsafe(t).add(e.multiplyUnsafe(f));return r.is0()?void 0:r}toAffine(e){return k(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return d===b||(e?e(F,this):j.unsafe(this,u).is0())}clearCofactor(){const{clearCofactor:e}=t;return d===b?this:e?e(F,this):this.multiplyUnsafe(d)}isSmallOrder(){return this.multiplyUnsafe(d).is0()}toBytes(e=!0){return(0,i.d6)(e,"isCompressed"),this.assertValidity(),v(F,this,e)}toHex(e=!0){return(0,o.My)(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return(0,s.Ak)(F,e)}static msm(e,t){return(0,s.Xf)(F,n,e,t)}static fromPrivateKey(e){return F.BASE.multiply(w(n,e))}}F.BASE=new F(a.Gx,a.Gy,r.ONE),F.ZERO=new F(r.ZERO,r.ONE,r.ZERO),F.Fp=r,F.Fn=n;const Z=n.BITS,j=new s.hT(F,t.endo?Math.ceil(Z/2):Z);return F.BASE.precompute(8),F}(t,f),r,l))}function x(e,t){const f=t=>v({...e,hash:t});return{...f(t),create:f}}const S={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},O={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},R={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},I=(0,a.D0)(S.p),K=(0,a.D0)(O.p),V=(0,a.D0)(R.p),P=x({...S,Fp:I,lowS:!1},r.sc),k=x({...O,Fp:K,lowS:!1},r.qt),q=x({...R,Fp:V,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},r.Zf)}}]);