/*! For license information please see 649.index.js.LICENSE.txt */
export const __webpack_esm_id__=649;export const __webpack_esm_ids__=[649];export const __webpack_esm_modules__={15916:(t,e,r)=>{r.d(e,{D0:()=>A,LH:()=>R,Tp:()=>F,dQ:()=>O,jr:()=>q,pS:()=>N,qy:()=>S,zH:()=>p,zi:()=>g});var n=r(78906),o=r(32531);const i=BigInt(0),s=BigInt(1),f=BigInt(2),u=BigInt(3),c=BigInt(4),l=BigInt(5),a=BigInt(7),d=BigInt(8),w=BigInt(9),h=BigInt(16);function g(t,e){const r=t%e;return r>=i?r:e+r}function p(t,e,r){let n=t;for(;e-- >i;)n*=n,n%=r;return n}function E(t,e){if(t===i)throw new Error("invert: expected non-zero number");if(e<=i)throw new Error("invert: expected positive modulus, got "+e);let r=g(t,e),n=e,o=i,f=s,u=s,c=i;for(;r!==i;){const t=n/r,e=n%r,i=o-u*t,s=f-c*t;n=r,r=e,o=u,f=c,u=i,c=s}if(n!==s)throw new Error("invert: does not exist");return g(o,e)}function m(t,e,r){if(!t.eql(t.sqr(e),r))throw new Error("Cannot find square root")}function b(t,e){const r=(t.ORDER+s)/c,n=t.pow(e,r);return m(t,n,e),n}function y(t,e){const r=(t.ORDER-l)/d,n=t.mul(e,f),o=t.pow(n,r),i=t.mul(e,o),s=t.mul(t.mul(i,f),o),u=t.mul(i,t.sub(s,t.ONE));return m(t,u,e),u}function v(t){if(t<u)throw new Error("sqrt is not defined for small field");let e=t-s,r=0;for(;e%f===i;)e/=f,r++;let n=f;const o=A(t);for(;1===x(o,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return b;let c=o.pow(n,e);const l=(e+s)/f;return function(t,n){if(t.is0(n))return n;if(1!==x(t,n))throw new Error("Cannot find square root");let o=r,i=t.mul(t.ONE,c),f=t.pow(n,e),u=t.pow(n,l);for(;!t.eql(f,t.ONE);){if(t.is0(f))return t.ZERO;let e=1,r=t.sqr(f);for(;!t.eql(r,t.ONE);)if(e++,r=t.sqr(r),e===o)throw new Error("Cannot find square root");const n=s<<BigInt(o-e-1),c=t.pow(i,n);o=e,i=t.sqr(c),f=t.mul(f,i),u=t.mul(u,c)}return u}}const O=(t,e)=>(g(t,e)&s)===s,B=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function q(t){const e=B.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,n.DS)(t,e),t}function N(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),o=e.reduce((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r)),t.ONE),i=t.inv(o);return e.reduceRight((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r)),i),n}function x(t,e){const r=(t.ORDER-s)/f,n=t.pow(e,r),o=t.eql(n,t.ONE),i=t.eql(n,t.ZERO),u=t.eql(n,t.neg(t.ONE));if(!o&&!i&&!u)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function R(t,e){void 0!==e&&(0,o.Fe)(e);const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function A(t,e,r=!1,o={}){if(t<=i)throw new Error("invalid field: expected ORDER > 0, got "+t);let f,p,O,B=!1;if("object"==typeof e&&null!=e){if(o.sqrt||r)throw new Error("cannot specify opts in two arguments");const t=e;t.BITS&&(f=t.BITS),t.sqrt&&(p=t.sqrt),"boolean"==typeof t.isLE&&(r=t.isLE),"boolean"==typeof t.modFromBytes&&(B=t.modFromBytes),O=t.allowedLengths}else"number"==typeof e&&(f=e),o.sqrt&&(p=o.sqrt);const{nBitLength:q,nByteLength:x}=R(t,f);if(x>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let I;const F=Object.freeze({ORDER:t,isLE:r,BITS:q,BYTES:x,MASK:(0,n.OG)(q),ZERO:i,ONE:s,allowedLengths:O,create:e=>g(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return i<=e&&e<t},is0:t=>t===i,isValidNot0:t=>!F.is0(t)&&F.isValid(t),isOdd:t=>(t&s)===s,neg:e=>g(-e,t),eql:(t,e)=>t===e,sqr:e=>g(e*e,t),add:(e,r)=>g(e+r,t),sub:(e,r)=>g(e-r,t),mul:(e,r)=>g(e*r,t),pow:(t,e)=>function(t,e,r){if(r<i)throw new Error("invalid exponent, negatives unsupported");if(r===i)return t.ONE;if(r===s)return e;let n=t.ONE,o=e;for(;r>i;)r&s&&(n=t.mul(n,o)),o=t.sqr(o),r>>=s;return n}(F,t,e),div:(e,r)=>g(e*E(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>E(e,t),sqrt:p||(e=>{return I||(I=(r=t)%c===u?b:r%d===l?y:r%h===w?function(t){const e=A(t),r=v(t),n=r(e,e.neg(e.ONE)),o=r(e,n),i=r(e,e.neg(n)),s=(t+a)/h;return(t,e)=>{let r=t.pow(e,s),f=t.mul(r,n);const u=t.mul(r,o),c=t.mul(r,i),l=t.eql(t.sqr(f),e),a=t.eql(t.sqr(u),e);r=t.cmov(r,f,l),f=t.cmov(c,u,a);const d=t.eql(t.sqr(f),e),w=t.cmov(r,f,d);return m(t,w,e),w}}(r):v(r)),I(F,e);var r}),toBytes:t=>r?(0,n.z)(t,x):(0,n.lq)(t,x),fromBytes:(e,o=!0)=>{if(O){if(!O.includes(e.length)||e.length>x)throw new Error("Field.fromBytes: expected "+O+" bytes, got "+e.length);const t=new Uint8Array(x);t.set(e,r?0:t.length-e.length),e=t}if(e.length!==x)throw new Error("Field.fromBytes: expected "+x+" bytes, got "+e.length);let i=r?(0,n.lX)(e):(0,n.Ph)(e);if(B&&(i=g(i,t)),!o&&!F.isValid(i))throw new Error("invalid field element: outside of range 0..ORDER");return i},invertBatch:t=>N(F,t),cmov:(t,e,r)=>r?e:t});return Object.freeze(F)}function I(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function F(t){const e=I(t);return e+Math.ceil(e/2)}function S(t,e,r=!1){const o=t.length,i=I(e),f=F(e);if(o<16||o<f||o>1024)throw new Error("expected "+f+"-1024 bytes of input, got "+o);const u=g(r?(0,n.lX)(t):(0,n.Ph)(t),e-s)+s;return r?(0,n.z)(u,i):(0,n.lq)(u,i)}},50649:(t,e,r)=>{r.d(e,{Ak:()=>u,UT:()=>y,Xf:()=>m,fH:()=>E,hT:()=>p,u0:()=>f});var n=r(78906),o=r(15916);const i=BigInt(0),s=BigInt(1);function f(t,e){const r=e.negate();return t?r:e}function u(t,e){const r=(0,o.pS)(t.Fp,e.map(t=>t.Z));return e.map((e,n)=>t.fromAffine(e.toAffine(r[n])))}function c(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function l(t,e){c(t,e);const r=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:(0,n.OG)(t),maxNumber:r,shiftBy:BigInt(t)}}function a(t,e,r){const{windowSize:n,mask:o,maxNumber:i,shiftBy:f}=r;let u=Number(t&o),c=t>>f;u>n&&(u-=i,c+=s);const l=e*n;return{nextN:c,offset:l+Math.abs(u)-1,isZero:0===u,isNeg:u<0,isNegF:e%2!=0,offsetF:l}}const d=new WeakMap,w=new WeakMap;function h(t){return w.get(t)||1}function g(t){if(t!==i)throw new Error("invalid wNAF")}class p{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,r=this.ZERO){let n=t;for(;e>i;)e&s&&(r=r.add(n)),n=n.double(),e>>=s;return r}precomputeWindow(t,e){const{windows:r,windowSize:n}=l(e,this.bits),o=[];let i=t,s=i;for(let t=0;t<r;t++){s=i,o.push(s);for(let t=1;t<n;t++)s=s.add(i),o.push(s);i=s.double()}return o}wNAF(t,e,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let n=this.ZERO,o=this.BASE;const i=l(t,this.bits);for(let t=0;t<i.windows;t++){const{nextN:s,offset:u,isZero:c,isNeg:l,isNegF:d,offsetF:w}=a(r,t,i);r=s,c?o=o.add(f(d,e[w])):n=n.add(f(l,e[u]))}return g(r),{p:n,f:o}}wNAFUnsafe(t,e,r,n=this.ZERO){const o=l(t,this.bits);for(let t=0;t<o.windows&&r!==i;t++){const{nextN:i,offset:s,isZero:f,isNeg:u}=a(r,t,o);if(r=i,!f){const t=e[s];n=n.add(u?t.negate():t)}}return g(r),n}getPrecomputes(t,e,r){let n=d.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&("function"==typeof r&&(n=r(n)),d.set(e,n))),n}cached(t,e,r){const n=h(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)}unsafe(t,e,r,n){const o=h(t);return 1===o?this._unsafeLadder(t,e,n):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),e,n)}createCache(t,e){c(e,this.bits),w.set(t,e),d.delete(t)}hasCache(t){return 1!==h(t)}}function E(t,e,r,n){let o=e,f=t.ZERO,u=t.ZERO;for(;r>i||n>i;)r&s&&(f=f.add(o)),n&s&&(u=u.add(o)),o=o.double(),r>>=s,n>>=s;return{p1:f,p2:u}}function m(t,e,r,o){(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})})(r,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}(o,e);const i=r.length,s=o.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const f=t.ZERO,u=(0,n.dJ)(BigInt(i));let c=1;u>12?c=u-3:u>4?c=u-2:u>0&&(c=2);const l=(0,n.OG)(c),a=new Array(Number(l)+1).fill(f);let d=f;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){a.fill(f);for(let e=0;e<s;e++){const n=o[e],i=Number(n>>BigInt(t)&l);a[i]=a[i].add(r[e])}let e=f;for(let t=a.length-1,r=f;t>0;t--)r=r.add(a[t]),e=e.add(r);if(d=d.add(e),0!==t)for(let t=0;t<c;t++)d=d.double()}return d}function b(t,e,r){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,o.jr)(e),e}return(0,o.D0)(t,{isLE:r})}function y(t,e,r={},n){if(void 0===n&&(n="edwards"===t),!e||"object"!=typeof e)throw new Error(`expected valid ${t} CURVE object`);for(const t of["p","n","h"]){const r=e[t];if(!("bigint"==typeof r&&r>i))throw new Error(`CURVE.${t} must be positive bigint`)}const o=b(e.p,r.Fp,n),s=b(e.n,r.Fn,n),f=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const t of f)if(!o.isValid(e[t]))throw new Error(`CURVE.${t} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:o,Fn:s}}},78906:(t,e,r)=>{r.d(e,{DS:()=>B,Mh:()=>E,OG:()=>v,Ph:()=>l,SJ:()=>q,aK:()=>b,d6:()=>s,dJ:()=>y,eV:()=>f,ex:()=>g,fg:()=>O,lX:()=>a,lq:()=>d,nC:()=>p,qj:()=>h,x:()=>N,z:()=>w,zW:()=>u});var n=r(32531);const o=BigInt(0),i=BigInt(1);function s(t,e=""){if("boolean"!=typeof t)throw new Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t);return t}function f(t,e,r=""){const o=(0,n.aY)(t),i=t?.length,s=void 0!==e;if(!o||s&&i!==e)throw new Error((r&&`"${r}" `)+"expected Uint8Array"+(s?` of length ${e}`:"")+", got "+(o?`length=${i}`:"type="+typeof t));return t}function u(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function c(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?o:BigInt("0x"+t)}function l(t){return c((0,n.My)(t))}function a(t){return(0,n.DO)(t),c((0,n.My)(Uint8Array.from(t).reverse()))}function d(t,e){return(0,n.aT)(t.toString(16).padStart(2*e,"0"))}function w(t,e){return d(t,e).reverse()}function h(t,e,r){let o;if("string"==typeof e)try{o=(0,n.aT)(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!(0,n.aY)(e))throw new Error(t+" must be hex string or Uint8Array");o=Uint8Array.from(e)}const i=o.length;if("number"==typeof r&&i!==r)throw new Error(t+" of length "+r+" expected, got "+i);return o}function g(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return 0===r}function p(t){return Uint8Array.from(t)}function E(t){return Uint8Array.from(t,(e,r)=>{const n=e.charCodeAt(0);if(1!==e.length||n>127)throw new Error(`string contains non-ASCII character "${t[r]}" with code ${n} at position ${r}`);return n})}const m=t=>"bigint"==typeof t&&o<=t;function b(t,e,r,n){if(!function(t,e,r){return m(t)&&m(e)&&m(r)&&e<=t&&t<r}(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function y(t){let e;for(e=0;t>o;t>>=i,e+=1);return e}const v=t=>(i<<BigInt(t))-i;function O(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");const o=t=>new Uint8Array(t),i=t=>Uint8Array.of(t);let s=o(t),f=o(t),u=0;const c=()=>{s.fill(1),f.fill(0),u=0},l=(...t)=>r(f,s,...t),a=(t=o(0))=>{f=l(i(0),t),s=l(),0!==t.length&&(f=l(i(1),t),s=l())},d=()=>{if(u++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){s=l();const e=s.slice();r.push(e),t+=s.length}return(0,n.Id)(...r)};return(t,e)=>{let r;for(c(),a(t);!(r=e(d()));)a();return c(),r}}function B(t,e,r={}){if(!t||"object"!=typeof t)throw new Error("expected valid options object");function n(e,r,n){const o=t[e];if(n&&void 0===o)return;const i=typeof o;if(i!==r||null===o)throw new Error(`param "${e}" is invalid: expected ${r}, got ${i}`)}Object.entries(e).forEach(([t,e])=>n(t,e,!1)),Object.entries(r).forEach(([t,e])=>n(t,e,!0))}const q=()=>{throw new Error("not implemented")};function N(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(void 0!==o)return o;const i=t(r,...n);return e.set(r,i),i}}}};