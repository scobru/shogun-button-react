/*! For license information please see 118.index.js.LICENSE.txt */
"use strict";(this.webpackChunkShogunButtonReact=this.webpackChunkShogunButtonReact||[]).push([[118],{13118:(t,e,n)=>{n.d(e,{ml_dsa87:()=>Et});const r=BigInt(2**32-1),o=BigInt(32);function s(t,e=!1){return e?{h:Number(t&r),l:Number(t>>o&r)}:{h:0|Number(t>>o&r),l:0|Number(t&r)}}function i(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function c(t,e=""){if(!Number.isSafeInteger(t)||t<0)throw new Error(`${e&&`"${e}" `}expected integer >= 0, got ${t}`)}function u(t,e,n=""){const r=i(t),o=t?.length,s=void 0!==e;if(!r||s&&o!==e)throw new Error((n&&`"${n}" `)+"expected Uint8Array"+(s?` of length ${e}`:"")+", got "+(r?`length=${o}`:"type="+typeof t));return t}function l(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function f(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function d(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}const h=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])()?t=>t:function(t){for(let e=0;e<t.length;e++)t[e]=d(t[e]);return t};function a(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];u(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}const g=t=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,t])}),y=BigInt(0),p=BigInt(1),w=BigInt(2),b=BigInt(7),L=BigInt(256),A=BigInt(113),E=[],m=[],k=[];for(let t=0,e=p,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],E.push(2*(5*r+n)),m.push((t+1)*(t+2)/2%64);let o=y;for(let t=0;t<7;t++)e=(e<<p^(e>>b)*A)%L,e&w&&(o^=p<<(p<<BigInt(t))-p);k.push(o)}const x=function(t,e=!1){const n=t.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let i=0;i<n;i++){const{h:n,l:c}=s(t[i],e);[r[i],o[i]]=[n,c]}return[r,o]}(k,!0),I=x[0],U=x[1],T=(t,e,n)=>n>32?((t,e,n)=>e<<n-32|t>>>64-n)(t,e,n):((t,e,n)=>t<<n|e>>>32-n)(t,e,n),v=(t,e,n)=>n>32?((t,e,n)=>t<<n-32|e>>>64-n)(t,e,n):((t,e,n)=>e<<n|t>>>32-n)(t,e,n);class O{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,e,n,r=!1,o=24){if(this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=r,this.rounds=o,c(n,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}clone(){return this._cloneInto()}keccak(){h(this.state32),function(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,o=(e+2)%10,s=n[o],i=n[o+1],c=T(s,i,1)^n[r],u=v(s,i,1)^n[r+1];for(let n=0;n<50;n+=10)t[e+n]^=c,t[e+n+1]^=u}let e=t[2],o=t[3];for(let n=0;n<24;n++){const r=m[n],s=T(e,o,r),i=v(e,o,r),c=E[n];e=t[c],o=t[c+1],t[c]=s,t[c+1]=i}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)n[r]=t[e+r];for(let r=0;r<10;r++)t[e+r]^=~n[(r+2)%10]&n[(r+4)%10]}t[0]^=I[r],t[1]^=U[r]}f(n)}(this.state32,this.rounds),h(this.state32),this.posOut=0,this.pos=0}update(t){l(this),u(t);const{blockLen:e,state:n}=this,r=t.length;for(let o=0;o<r;){const s=Math.min(e-this.pos,r-o);for(let e=0;e<s;e++)n[this.pos++]^=t[o++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,128&e&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){l(this,!1),u(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,o-r);t.set(e.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return c(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){u(t,void 0,"digestInto() output");const n=e.outputLen;if(t.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,f(this.state)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:o,enableXOF:s}=this;return t||=new O(e,n,r,s,o),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=n,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}const M=(t,e,n,r={})=>function(t,e={}){const n=(e,n)=>t(n).update(e).digest(),r=t(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=e=>t(e),Object.assign(n,e),Object.freeze(n)}((r={})=>new O(e,t,void 0===r.dkLen?n:r.dkLen,!0),r),B=M(31,168,16,g(11)),F=M(31,136,32,g(12));function N(t){if(!Number.isSafeInteger(t)||t<0||t>4294967295)throw new Error("wrong u32 integer:"+t);return t}function K(t){return N(t),!(t&t-1)&&0!==t}function _(t,e){N(t);let n=0;for(let r=0;r<e;r++,t>>>=1)n=n<<1|1&t;return n}function R(t){return N(t),31-Math.clz32(t)}function S(t){const e=t.length;if(e<2||!K(e))throw new Error("n must be a power of 2 and greater than 1. Got "+e);const n=R(e);for(let r=0;r<e;r++){const e=_(r,n);if(r<e){const n=t[r];t[r]=t[e],t[e]=n}}return t}const $=(t,e)=>{const{N:n,roots:r,dit:o,invertButterflies:s=!1,skipStages:i=0,brp:c=!0}=e,u=R(n);if(!K(n))throw new Error("FFT: Polynomial size should be power of two");const l=o!==s;return e=>{if(e.length!==n)throw new Error("FFT: wrong Polynomial length");o&&c&&S(e);for(let c=0,f=1;c<u-i;c++){const d=o?c+1+i:u-c,h=1<<d,a=h>>1,g=n>>d;for(let i=0;i<n;i+=h)for(let c=0,u=f++;c<a;c++){const f=i+c,d=i+c+a,h=r[s?o?n-u:u:c*g],y=e[d],p=e[f];if(l){const n=t.mul(y,h);e[f]=t.add(p,n),e[d]=t.sub(p,n)}else s?(e[f]=t.add(y,p),e[d]=t.mul(t.sub(y,p),h)):(e[f]=t.add(p,y),e[d]=t.mul(t.sub(p,y),h))}}return!o&&c&&S(e),e}},P=function(t=32){const e="object"==typeof globalThis?globalThis.crypto:null;if("function"!=typeof e?.getRandomValues)throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(t))};function X(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n}function C(t){if("object"!=typeof t||null===t||i(t))throw new Error("expected opts to be an object")}function G(t){C(t),void 0!==t.context&&u(t.context,void 0,"opts.context")}function Y(t){G(t),!1!==t.extraEntropy&&void 0!==t.extraEntropy&&u(t.extraEntropy,void 0,"opts.extraEntropy")}function j(t,...e){const n=t=>"number"==typeof t?t:t.bytesLen,r=e.reduce((t,e)=>t+n(e),0);return{bytesLen:r,encode:o=>{const s=new Uint8Array(r);for(let r=0,i=0;r<e.length;r++){const c=e[r],l=n(c),f="number"==typeof c?o[r]:c.encode(o[r]);u(f,l,t),s.set(f,i),"number"!=typeof c&&f.fill(0),i+=l}return s},decode:o=>{u(o,r,t);const s=[];for(const t of e){const e=n(t),r=o.subarray(0,e);s.push("number"==typeof t?r:t.decode(r)),o=o.subarray(e)}return s}}}function H(t,e){const n=e*t.bytesLen;return{bytesLen:n,encode:r=>{if(r.length!==e)throw new Error(`vecCoder.encode: wrong length=${r.length}. Expected: ${e}`);const o=new Uint8Array(n);for(let e=0,n=0;e<r.length;e++){const s=t.encode(r[e]);o.set(s,n),s.fill(0),n+=s.length}return o},decode:e=>{u(e,n);const r=[];for(let n=0;n<e.length;n+=t.bytesLen)r.push(t.decode(e.subarray(n,n+t.bytesLen)));return r}}}function V(...t){for(const e of t)if(Array.isArray(e))for(const t of e)t.fill(0);else e.fill(0)}function z(t){return(1<<t)-1}const D=Uint8Array.of();function W(t,e=D){if(u(t),u(e),e.length>255)throw new Error("context should be less than 255 bytes");return a(new Uint8Array([0,e.length]),e,t)}const Q=Uint8Array.from([6,9,96,134,72,1,101,3,4,2]);function q(t,e,n=D){if(u(e),u(n),n.length>255)throw new Error("context should be less than 255 bytes");const r=t(e);return a(new Uint8Array([1,n.length]),n,t.oid,r)}const Z=t=>(e,n)=>{n||(n=t.blockLen);const r=new Uint8Array(e.length+2);r.set(e);const o=e.length,s=new Uint8Array(n);let i=t.create({}),c=0,u=0;return{stats:()=>({calls:c,xofs:u}),get:(e,n)=>(r[o+0]=e,r[o+1]=n,i.destroy(),i=t.create({}).update(r),c++,()=>(u++,i.xofInto(s))),clean:()=>{i.destroy(),V(s,r)}}},J=Z(B),tt=Z(F);function et(t){C(t),void 0!==t.externalMu&&function(t,e=""){if("boolean"!=typeof t)throw new Error((e&&`"${e}" `)+"expected boolean, got type="+typeof t)}(t.externalMu,"opts.externalMu")}const nt=256,rt=8380417,ot=0|Math.floor(95232),st=0|Math.floor(261888),it={K:8,L:7,D:13,GAMMA1:2**19,GAMMA2:st,TAU:60,ETA:2,OMEGA:75},ct=t=>new Int32Array(t),{mod:ut,smod:lt,NTT:ft,bitsCoder:dt}=(t=>{const{newPoly:e,N:n,Q:r,F:o,ROOT_OF_UNITY:s,brvBits:i,isKyber:c}=t,u=(t,e=r)=>{const n=t%e|0;return 0|(n>=0?n:e+n)},l=function(){const t=e(n);for(let e=0;e<n;e++){const n=_(e,i),o=BigInt(s)**BigInt(n)%BigInt(r);t[e]=0|Number(o)}return t}(),f={add:(t,e)=>0|u((0|t)+(0|e)),sub:(t,e)=>0|u((0|t)-(0|e)),mul:(t,e)=>0|u((0|t)*(0|e)),inv:t=>{throw new Error("not implemented")}},d={N:n,roots:l,invertButterflies:!0,skipStages:c?1:0,brp:!1},h=$(f,{dit:!1,...d}),a=$(f,{dit:!0,...d}),g={encode:t=>h(t),decode:t=>{a(t);for(let e=0;e<t.length;e++)t[e]=u(o*t[e]);return t}};return{mod:u,smod:(t,e=r)=>{const n=0|u(t,e);return 0|(n>e>>1?n-e:n)},nttZetas:l,NTT:g,bitsCoder:(t,r)=>{const o=z(t),s=t*(n/8);return{bytesLen:s,encode:e=>{const n=new Uint8Array(s);for(let s=0,i=0,c=0,u=0;s<e.length;s++)for(i|=(r.encode(e[s])&o)<<c,c+=t;c>=8;c-=8,i>>=8)n[u++]=i&z(c);return n},decode:s=>{const i=e(n);for(let e=0,n=0,c=0,u=0;e<s.length;e++)for(n|=s[e]<<c,c+=8;c>=t;c-=t,n>>=t)i[u++]=r.decode(n&o);return i}}}}})({N:nt,Q:rt,F:8347681,ROOT_OF_UNITY:1753,newPoly:ct,isKyber:!1,brvBits:8}),ht=t=>t,at=(t,e=ht,n=ht)=>dt(t,{encode:t=>e(n(t)),decode:t=>n(e(t))}),gt=(t,e)=>{for(let n=0;n<t.length;n++)t[n]=ut(t[n]+e[n]);return t},yt=(t,e)=>{for(let n=0;n<t.length;n++)t[n]=ut(t[n]-e[n]);return t},pt=t=>{for(let e=0;e<nt;e++)t[e]<<=13;return t},wt=(t,e)=>{for(let n=0;n<nt;n++)if(Math.abs(lt(t[n]))>=e)return!0;return!1},bt=(t,e)=>{const n=ct(nt);for(let r=0;r<t.length;r++)n[r]=ut(t[r]*e[r]);return n};function Lt(t){const e=ct(nt);for(let n=0;n<nt;){const r=t();if(r.length%3)throw new Error("RejNTTPoly: unaligned block");for(let t=0;n<nt&&t<=r.length-3;t+=3){const o=8388607&(r[t+0]|r[t+1]<<8|r[t+2]<<16);o<rt&&(e[n++]=o)}}return e}function At(t){const{K:e,L:n,GAMMA1:r,GAMMA2:o,TAU:s,ETA:i,OMEGA:c}=t,{CRH_BYTES:l,TR_BYTES:f,C_TILDE_BYTES:d,XOF128:h,XOF256:a,securityLevel:g}=t;if(![2,4].includes(i))throw new Error("Wrong ETA");if(![1<<17,1<<19].includes(r))throw new Error("Wrong GAMMA1");if(![ot,st].includes(o))throw new Error("Wrong GAMMA2");const y=s*i,p=t=>{const e=ut(t),n=0|lt(e,2*o);return e-n===rt-1?{r1:0,r0:n-1|0}:{r1:0|Math.floor((e-n)/(2*o)),r0:n}},w=t=>p(t).r1,b=t=>p(t).r0,L=(t,e)=>t<=o||t>rt-o||t===rt-o&&0===e?0:1,A=(t,e)=>{const n=Math.floor((rt-1)/(2*o)),{r1:r,r0:s}=p(e);return 1===t?s>0?0|ut(r+1,n):0|ut(r-1,n):0|r},E=t=>{const e=ut(t),n=0|lt(e,8192);return{r1:0|Math.floor((e-n)/8192),r0:n}},m={bytesLen:c+e,encode:t=>{if(!1===t)throw new Error("hint.encode: hint is false");const n=new Uint8Array(c+e);for(let r=0,o=0;r<e;r++){for(let e=0;e<nt;e++)0!==t[r][e]&&(n[o++]=e);n[c+r]=o}return n},decode:t=>{const n=[];let r=0;for(let o=0;o<e;o++){const e=ct(nt);if(t[c+o]<r||t[c+o]>c)return!1;for(let n=r;n<t[c+o];n++){if(n>r&&t[n]<=t[n-1])return!1;e[t[n]]=1}r=t[c+o],n.push(e)}for(let e=r;e<c;e++)if(0!==t[e])return!1;return n}},k=at(2===i?3:4,t=>i-t,t=>{if(!(-i<=t&&t<=i))throw new Error(`malformed key s1/s3 ${t} outside of ETA range [${-i}, ${i}]`);return t}),x=at(13,t=>4096-t),I=at(10),U=at(r===1<<17?18:20,t=>lt(r-t)),T=H(at(o===ot?6:4),e),v=j("publicKey",32,H(I,e)),O=j("secretKey",32,32,f,H(k,n),H(k,e),H(x,e)),M=j("signature",d,H(U,n),m),B=2===i?t=>t<15&&2-t%5:t=>t<9&&4-t;function N(t){const e=ct(nt);for(let n=0;n<nt;){const r=t();for(let t=0;n<nt&&t<r.length;t+=1){const o=B(15&r[t]),s=B(r[t]>>4&15);!1!==o&&(e[n++]=o),n<nt&&!1!==s&&(e[n++]=s)}}return e}const K=t=>{const e=ct(nt),n=F.create({}).update(t),r=new Uint8Array(F.blockLen);n.xofInto(r);const o=r.slice(0,8);for(let t=nt-s,i=8,c=0,u=0;t<nt;t++){let s=t+1;for(;s>t;)s=r[i++],i<F.blockLen||(n.xofInto(r),i=0);e[t]=e[s],e[s]=1-((o[c]>>u++&1)<<1),u>=8&&(c++,u=0)}return e},_=t=>{const e=ct(nt),n=ct(nt);for(let r=0;r<t.length;r++){const{r0:o,r1:s}=E(t[r]);e[r]=o,n[r]=s}return{r0:e,r1:n}},R=(t,e)=>{for(let n=0;n<nt;n++)t[n]=A(e[n],t[n]);return t},S=(t,e)=>{const n=ct(nt);let r=0;for(let o=0;o<nt;o++){const s=L(t[o],e[o]);n[o]=s,r+=s}return{v:n,cnt:r}},$=j("seed",32,64,32),C={info:{type:"internal-ml-dsa"},lengths:{secretKey:O.bytesLen,publicKey:v.bytesLen,seed:32,signature:M.bytesLen,signRand:32},keygen:t=>{const r=new Uint8Array(34),o=void 0===t;o&&(t=P(32)),u(t,32,"seed"),r.set(t),o&&V(t),r[32]=e,r[33]=n;const[s,i,c]=$.decode(F(r,{dkLen:$.bytesLen})),l=a(i),d=[];for(let t=0;t<n;t++)d.push(N(l.get(255&t,t>>8&255)));const g=[];for(let t=n;t<n+e;t++)g.push(N(l.get(255&t,t>>8&255)));const y=d.map(t=>ft.encode(t.slice())),p=[],w=[],b=h(s),L=ct(nt);for(let t=0;t<e;t++){V(L);for(let e=0;e<n;e++){const n=Lt(b.get(e,t));gt(L,bt(n,y[e]))}ft.decode(L);const{r0:e,r1:r}=_(gt(L,g[t]));p.push(e),w.push(r)}const A=v.encode([s,w]),E=F(A,{dkLen:f}),m=O.encode([s,c,E,d,g,p]);return b.clean(),l.clean(),V(s,i,c,d,g,y,L,p,w,E,r),{publicKey:A,secretKey:m}},getPublicKey:t=>{const[r,o,s,i,c,u]=O.decode(t),l=h(r),f=i.map(t=>ft.encode(t.slice())),d=[],a=ct(nt);for(let t=0;t<e;t++){a.fill(0);for(let e=0;e<n;e++){const n=Lt(l.get(e,t));gt(a,bt(n,f[e]))}ft.decode(a),gt(a,c[t]);const{r1:e}=_(a);d.push(e)}return l.clean(),V(a,f,u,i,c),v.encode([r,d])},sign:(t,s,i={})=>{Y(i),et(i);let{extraEntropy:f,externalMu:g=!1}=i;const[p,L,A,E,m,k]=O.decode(s),x=[],I=h(p);for(let t=0;t<e;t++){const e=[];for(let r=0;r<n;r++)e.push(Lt(I.get(r,t)));x.push(e)}I.clean();for(let t=0;t<n;t++)ft.encode(E[t]);for(let t=0;t<e;t++)ft.encode(m[t]),ft.encode(k[t]);const v=g?t:F.create({dkLen:l}).update(A).update(t).digest(),B=!1===f?new Uint8Array(32):void 0===f?P(32):f;u(B,32,"extraEntropy");const N=F.create({dkLen:l}).update(L).update(B).update(v).digest();u(N,l);const _=a(N,U.bytesLen);t:for(let t=0;;){const s=[];for(let e=0;e<n;e++,t++)s.push(U.decode(_.get(255&t,t>>8)()));const i=s.map(t=>ft.encode(t.slice())),u=[];for(let t=0;t<e;t++){const e=ct(nt);for(let r=0;r<n;r++)gt(e,bt(x[t][r],i[r]));ft.decode(e),u.push(e)}const l=u.map(t=>t.map(w)),f=F.create({dkLen:d}).update(v).update(T.encode(l)).digest(),h=ft.encode(K(f)),a=E.map(t=>bt(t,h));for(let t=0;t<n;t++)if(gt(ft.decode(a[t]),s[t]),wt(a[t],r-y))continue t;let g=0;const p=[];for(let t=0;t<e;t++){const e=ft.decode(bt(m[t],h)),n=yt(u[t],e).map(b);if(wt(n,o-y))continue t;const r=ft.decode(bt(k[t],h));if(wt(r,o))continue t;gt(n,r);const s=S(n,l[t]);p.push(s.v),g+=s.cnt}if(g>c)continue;_.clean();const L=M.encode([f,a,p]);return V(f,a,p,h,l,u,i,s,N,v,E,m,k,...x),L}throw new Error("Unreachable code path reached, report this error")},verify:(t,o,s,i={})=>{et(i);const{externalMu:u=!1}=i,[a,g]=v.decode(s),p=F(s,{dkLen:f});if(t.length!==M.bytesLen)return!1;const[w,b,L]=M.decode(t);if(!1===L)return!1;for(let t=0;t<n;t++)if(wt(b[t],r-y))return!1;const A=u?o:F.create({dkLen:l}).update(p).update(o).digest(),E=ft.encode(K(w)),m=b.map(t=>t.slice());for(let t=0;t<n;t++)ft.encode(m[t]);const k=[],x=h(a);for(let t=0;t<e;t++){const e=bt(ft.encode(pt(g[t])),E),r=ct(nt);for(let e=0;e<n;e++){const n=Lt(x.get(e,t));gt(r,bt(n,m[e]))}const o=ft.decode(yt(r,e));k.push(R(o,L[t]))}x.clean();const I=F.create({dkLen:d}).update(A).update(T.encode(k)).digest();for(const t of L)if(!(t.reduce((t,e)=>t+e,0)<=c))return!1;for(const t of b)if(wt(t,r-y))return!1;return X(w,I)}};return{info:{type:"ml-dsa"},internal:C,securityLevel:g,keygen:C.keygen,lengths:C.lengths,getPublicKey:C.getPublicKey,sign:(t,e,n={})=>{Y(n);const r=W(t,n.context),o=C.sign(r,e,n);return V(r),o},verify:(t,e,n,r={})=>(G(r),C.verify(t,W(e,r.context),n)),prehash:t=>(function(t,e=0){if(!t.oid||!X(t.oid.subarray(0,10),Q))throw new Error("hash.oid is invalid: expected NIST hash");const n=8*t.outputLen/2;if(e>n)throw new Error("Pre-hash security strength too low: "+n+", required: "+e)}(t,g),{info:{type:"hashml-dsa"},securityLevel:g,lengths:C.lengths,keygen:C.keygen,getPublicKey:C.getPublicKey,sign:(e,n,r={})=>{Y(r);const o=q(t,e,r.context),s=C.sign(o,n,r);return V(o),s},verify:(e,n,r,o={})=>(G(o),C.verify(e,q(t,n,o.context),r))})}}const Et=At({...it,CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:64,XOF128:J,XOF256:tt,securityLevel:256})}}]);