/*! For license information please see 195.index.js.LICENSE.txt */
export const __webpack_esm_id__=195;export const __webpack_esm_ids__=[195];export const __webpack_esm_modules__={5385:(t,e,r)=>{r.d(e,{Tq:()=>f,qX:()=>p,qj:()=>y,zc:()=>d});var n=r(8906),i=r(2531),s=r(5916);const o=n.Ph;function a(t,e){if(c(t),c(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function u(t,e){const r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function c(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function h(t){if(!(0,i.aY)(t)&&"string"!=typeof t)throw new Error("DST must be Uint8Array or string");return"string"==typeof t?(0,i.AI)(t):t}function f(t,e,r,n){(0,i.DO)(t),c(r),(e=h(e)).length>255&&(e=n((0,i.Id)((0,i.AI)("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:o}=n,f=Math.ceil(r/s);if(r>65535||f>255)throw new Error("expand_message_xmd: invalid lenInBytes");const d=(0,i.Id)(e,a(e.length,1)),l=a(0,o),p=a(r,2),y=new Array(f),m=n((0,i.Id)(l,t,p,a(0,1),d));y[0]=n((0,i.Id)(m,a(1,1),d));for(let t=1;t<=f;t++){const e=[u(m,y[t-1]),a(t+1,1),d];y[t]=n((0,i.Id)(...e))}return(0,i.Id)(...y).slice(0,r)}function d(t,e,r,n,s){if((0,i.DO)(t),c(r),(e=h(e)).length>255){const t=Math.ceil(2*n/8);e=s.create({dkLen:t}).update((0,i.AI)("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:r}).update(t).update(a(r,2)).update(e).update(a(e.length,1)).digest()}function l(t,e,r){(0,n.DS)(r,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:a,k:u,m:h,hash:l,expand:p,DST:y}=r;if(!(0,n.jN)(r.hash))throw new Error("expected valid hash");(0,i.DO)(t),c(e);const m=a.toString(2).length,w=Math.ceil((m+u)/8),g=e*h*w;let x;if("xmd"===p)x=f(t,y,g,l);else if("xof"===p)x=d(t,y,g,u,l);else{if("_internal_pass"!==p)throw new Error('expand must be "xmd" or "xof"');x=t}const E=new Array(e);for(let t=0;t<e;t++){const e=new Array(h);for(let r=0;r<h;r++){const n=w*(r+t*h),i=x.subarray(n,n+w);e[r]=(0,s.zi)(o(i),a)}E[t]=e}return E}const p=(0,i.AI)("HashToScalar-");function y(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");function n(r){return t.fromAffine(e(r))}function i(e){const r=e.clearCofactor();return r.equals(t.ZERO)?t.ZERO:(r.assertValidity(),r)}return{defaults:r,hashToCurve(t,e){const s=l(t,2,Object.assign({},r,e)),o=n(s[0]),a=n(s[1]);return i(o.add(a))},encodeToCurve(t,e){const s=r.encodeDST?{DST:r.encodeDST}:{};return i(n(l(t,1,Object.assign({},r,s,e))[0]))},mapToCurve(t){if(!Array.isArray(t))throw new Error("expected array of bigints");for(const e of t)if("bigint"!=typeof e)throw new Error("expected array of bigints");return i(n(t))},hashToScalar(e,n){const i=t.Fn.ORDER;return l(e,1,Object.assign({},r,{p:i,m:1,DST:p},n))[0][0]}}}},6618:(t,e,r)=>{r.d(e,{TO:()=>f,i5:()=>d,n6:()=>l});var n=r(8906),i=r(2531),s=r(649),o=r(5916);const a=BigInt(0),u=BigInt(1),c=BigInt(2),h=BigInt(8);function f(t,e={}){const r=(0,s.UT)("edwards",t,e,e.FpFnLE),{Fp:o,Fn:f}=r;let d=r.CURVE;const{h:l}=d;(0,n.DS)(e,{},{uvRatio:"function"});const p=c<<BigInt(8*f.BYTES)-u,y=t=>o.create(t),m=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:o.sqrt(o.div(t,e))}}catch(t){return{isValid:!1,value:a}}});if(!function(t,e,r,n){const i=t.sqr(r),s=t.sqr(n),o=t.add(t.mul(e.a,i),s),a=t.add(t.ONE,t.mul(e.d,t.mul(i,s)));return t.eql(o,a)}(o,d,d.Gx,d.Gy))throw new Error("bad curve params: generator point");function w(t,e,r=!1){const i=r?u:a;return(0,n.aK)("coordinate "+t,e,i,p),e}function g(t){if(!(t instanceof B))throw new Error("ExtendedPoint expected")}const x=(0,n.x)((t,e)=>{const{X:r,Y:n,Z:i}=t,s=t.is0();null==e&&(e=s?h:o.inv(i));const c=y(r*e),f=y(n*e),d=o.mul(i,e);if(s)return{x:a,y:u};if(d!==u)throw new Error("invZ was invalid");return{x:c,y:f}}),E=(0,n.x)(t=>{const{a:e,d:r}=d;if(t.is0())throw new Error("bad point: ZERO");const{X:n,Y:i,Z:s,T:o}=t,a=y(n*n),u=y(i*i),c=y(s*s),h=y(c*c),f=y(a*e);if(y(c*y(f+u))!==y(h+y(r*y(a*u))))throw new Error("bad point: equation left != right (1)");if(y(n*i)!==y(s*o))throw new Error("bad point: equation left != right (2)");return!0});class B{constructor(t,e,r,n){this.X=w("x",t),this.Y=w("y",e),this.Z=w("z",r,!0),this.T=w("t",n),Object.freeze(this)}static CURVE(){return d}static fromAffine(t){if(t instanceof B)throw new Error("extended point not allowed");const{x:e,y:r}=t||{};return w("x",e),w("y",r),new B(e,r,u,y(e*r))}static fromBytes(t,e=!1){const r=o.BYTES,{a:i,d:s}=d;t=(0,n.nC)((0,n.eV)(t,r,"point")),(0,n.d6)(e,"zip215");const c=(0,n.nC)(t),h=t[r-1];c[r-1]=-129&h;const f=(0,n.lX)(c),l=e?p:o.ORDER;(0,n.aK)("point.y",f,a,l);const w=y(f*f),g=y(w-u),x=y(s*w-i);let{isValid:E,value:b}=m(g,x);if(!E)throw new Error("bad point: invalid y coordinate");const S=(b&u)===u,v=!!(128&h);if(!e&&b===a&&v)throw new Error("bad point: x=0 and x_0=1");return v!==S&&(b=y(-b)),B.fromAffine({x:b,y:f})}static fromHex(t,e=!1){return B.fromBytes((0,n.qj)("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return b.createCache(this,t),e||this.multiply(c),this}assertValidity(){E(this)}equals(t){g(t);const{X:e,Y:r,Z:n}=this,{X:i,Y:s,Z:o}=t,a=y(e*o),u=y(i*n),c=y(r*o),h=y(s*n);return a===u&&c===h}is0(){return this.equals(B.ZERO)}negate(){return new B(y(-this.X),this.Y,this.Z,y(-this.T))}double(){const{a:t}=d,{X:e,Y:r,Z:n}=this,i=y(e*e),s=y(r*r),o=y(c*y(n*n)),a=y(t*i),u=e+r,h=y(y(u*u)-i-s),f=a+s,l=f-o,p=a-s,m=y(h*l),w=y(f*p),g=y(h*p),x=y(l*f);return new B(m,w,x,g)}add(t){g(t);const{a:e,d:r}=d,{X:n,Y:i,Z:s,T:o}=this,{X:a,Y:u,Z:c,T:h}=t,f=y(n*a),l=y(i*u),p=y(o*r*h),m=y(s*c),w=y((n+i)*(a+u)-f-l),x=m-p,E=m+p,b=y(l-e*f),S=y(w*x),v=y(E*b),T=y(w*b),A=y(x*E);return new B(S,v,A,T)}subtract(t){return this.add(t.negate())}multiply(t){if(!f.isValidNot0(t))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f:r}=b.cached(this,t,t=>(0,s.Ak)(B,t));return(0,s.Ak)(B,[e,r])[0]}multiplyUnsafe(t,e=B.ZERO){if(!f.isValid(t))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return t===a?B.ZERO:this.is0()||t===u?this:b.unsafe(this,t,t=>(0,s.Ak)(B,t),e)}isSmallOrder(){return this.multiplyUnsafe(l).is0()}isTorsionFree(){return b.unsafe(this,d.n).is0()}toAffine(t){return x(this,t)}clearCofactor(){return l===u?this:this.multiplyUnsafe(l)}toBytes(){const{x:t,y:e}=this.toAffine(),r=o.toBytes(e);return r[r.length-1]|=t&u?128:0,r}toHex(){return(0,i.My)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return(0,s.Ak)(B,t)}static msm(t,e){return(0,s.Xf)(B,f,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}B.BASE=new B(d.Gx,d.Gy,u,y(d.Gx*d.Gy)),B.ZERO=new B(a,u,u,a),B.Fp=o,B.Fn=f;const b=new s.hT(B,f.BITS);return B.BASE.precompute(8),B}class d{constructor(t){this.ep=t}static fromBytes(t){(0,n.SJ)()}static fromHex(t){(0,n.SJ)()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(t){return this.ep.toAffine(t)}toHex(){return(0,i.My)(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(t){return this.assertSame(t),this.init(this.ep.add(t.ep))}subtract(t){return this.assertSame(t),this.init(this.ep.subtract(t.ep))}multiply(t){return this.init(this.ep.multiply(t))}multiplyUnsafe(t){return this.init(this.ep.multiplyUnsafe(t))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(t,e){return this.init(this.ep.precompute(t,e))}toRawBytes(){return this.toBytes()}}function l(t){const{CURVE:e,curveOpts:r,hash:s,eddsaOpts:a}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r={Fp:t.Fp,Fn:(0,o.D0)(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},n={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:r,hash:t.hash,eddsaOpts:n}}(t);return function(t,e){const r=e.Point;return Object.assign({},e,{ExtendedPoint:r,CURVE:t,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(t,function(t,e,r={}){if("function"!=typeof e)throw new Error('"hash" function param is required');(0,n.DS)(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:s}=r,{BASE:o,Fp:a,Fn:c}=t,h=r.randomBytes||i.po,f=r.adjustScalarBytes||(t=>t),d=r.domain||((t,e,r)=>{if((0,n.d6)(r,"phflag"),e.length||r)throw new Error("Contexts/pre-hash are not supported");return t});function l(t){return c.create((0,n.lX)(t))}function p(t){const{head:r,prefix:i,scalar:s}=function(t){const r=x.secretKey;t=(0,n.qj)("private key",t,r);const i=(0,n.qj)("hashed private key",e(t),2*r),s=f(i.slice(0,r));return{head:s,prefix:i.slice(r,2*r),scalar:l(s)}}(t),a=o.multiply(s),u=a.toBytes();return{head:r,prefix:i,scalar:s,point:a,pointBytes:u}}function y(t){return p(t).pointBytes}function m(t=Uint8Array.of(),...r){const o=(0,i.Id)(...r);return l(e(d(o,(0,n.qj)("context",t),!!s)))}const w={zip215:!0},g=a.BYTES,x={secretKey:g,publicKey:g,signature:2*g,seed:g};function E(t=h(x.seed)){return(0,n.eV)(t,x.seed,"seed")}const B={getExtendedPublicKey:p,randomSecretKey:E,isValidSecretKey:function(t){return(0,i.aY)(t)&&t.length===c.BYTES},isValidPublicKey:function(e,r){try{return!!t.fromBytes(e,r)}catch(t){return!1}},toMontgomery(e){const{y:r}=t.fromBytes(e),n=x.publicKey,i=32===n;if(!i&&57!==n)throw new Error("only defined for 25519 and 448");const s=i?a.div(u+r,u-r):a.div(r-u,r+u);return a.toBytes(s)},toMontgomerySecret(t){const r=x.secretKey;(0,n.eV)(t,r);const i=e(t.subarray(0,r));return f(i).subarray(0,r)},randomPrivateKey:E,precompute:(e=8,r=t.BASE)=>r.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=B.randomSecretKey(t);return{secretKey:e,publicKey:y(e)}},getPublicKey:y,sign:function(t,e,r={}){t=(0,n.qj)("message",t),s&&(t=s(t));const{prefix:a,scalar:u,pointBytes:h}=p(e),f=m(r.context,a,t),d=o.multiply(f).toBytes(),l=m(r.context,d,h,t),y=c.create(f+l*u);if(!c.isValid(y))throw new Error("sign failed: invalid s");const w=(0,i.Id)(d,c.toBytes(y));return(0,n.eV)(w,x.signature,"result")},verify:function(e,r,i,a=w){const{context:u,zip215:c}=a,h=x.signature;e=(0,n.qj)("signature",e,h),r=(0,n.qj)("message",r),i=(0,n.qj)("publicKey",i,x.publicKey),void 0!==c&&(0,n.d6)(c,"zip215"),s&&(r=s(r));const f=h/2,d=e.subarray(0,f),l=(0,n.lX)(e.subarray(f,h));let p,y,g;try{p=t.fromBytes(i,c),y=t.fromBytes(d,c),g=o.multiplyUnsafe(l)}catch(t){return!1}if(!c&&p.isSmallOrder())return!1;const E=m(u,y.toBytes(),p.toBytes(),r);return y.add(p.multiplyUnsafe(E)).subtract(g).clearCofactor().is0()},utils:B,Point:t,lengths:x})}(f(e,r),s,a))}}};