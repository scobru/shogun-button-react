/*! For license information please see 195.index.js.LICENSE.txt */
"use strict";(this.webpackChunkShogunButtonReact=this.webpackChunkShogunButtonReact||[]).push([[195],{7766:(t,e,r)=>{r.d(e,{Tq:()=>u,qX:()=>h,zc:()=>c});var n=r(32531);function i(t,e){if(o(t),o(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function s(t,e){const r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function o(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function a(t){if(!(0,n.aY)(t)&&"string"!=typeof t)throw new Error("DST must be Uint8Array or string");return"string"==typeof t?(0,n.AI)(t):t}function u(t,e,r,u){(0,n.DO)(t),o(r),(e=a(e)).length>255&&(e=u((0,n.Id)((0,n.AI)("H2C-OVERSIZE-DST-"),e)));const{outputLen:c,blockLen:h}=u,d=Math.ceil(r/c);if(r>65535||d>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,n.Id)(e,i(e.length,1)),f=i(0,h),p=i(r,2),y=new Array(d),m=u((0,n.Id)(f,t,p,i(0,1),l));y[0]=u((0,n.Id)(m,i(1,1),l));for(let t=1;t<=d;t++){const e=[s(m,y[t-1]),i(t+1,1),l];y[t]=u((0,n.Id)(...e))}return(0,n.Id)(...y).slice(0,r)}function c(t,e,r,s,u){if((0,n.DO)(t),o(r),(e=a(e)).length>255){const t=Math.ceil(2*s/8);e=u.create({dkLen:t}).update((0,n.AI)("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return u.create({dkLen:r}).update(t).update(i(r,2)).update(e).update(i(e.length,1)).digest()}const h=(0,n.AI)("HashToScalar-")},26618:(t,e,r)=>{r.d(e,{TO:()=>d,i5:()=>l,n6:()=>f});var n=r(78906),i=r(32531),s=r(50649),o=r(15916);const a=BigInt(0),u=BigInt(1),c=BigInt(2),h=BigInt(8);function d(t,e={}){const r=(0,s.UT)("edwards",t,e,e.FpFnLE),{Fp:o,Fn:d}=r;let l=r.CURVE;const{h:f}=l;(0,n.DS)(e,{},{uvRatio:"function"});const p=c<<BigInt(8*d.BYTES)-u,y=t=>o.create(t),m=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:o.sqrt(o.div(t,e))}}catch(t){return{isValid:!1,value:a}}});if(!function(t,e,r,n){const i=t.sqr(r),s=t.sqr(n),o=t.add(t.mul(e.a,i),s),a=t.add(t.ONE,t.mul(e.d,t.mul(i,s)));return t.eql(o,a)}(o,l,l.Gx,l.Gy))throw new Error("bad curve params: generator point");function g(t,e,r=!1){const i=r?u:a;return(0,n.aK)("coordinate "+t,e,i,p),e}function w(t){if(!(t instanceof x))throw new Error("ExtendedPoint expected")}const B=(0,n.x)((t,e)=>{const{X:r,Y:n,Z:i}=t,s=t.is0();null==e&&(e=s?h:o.inv(i));const c=y(r*e),d=y(n*e),l=o.mul(i,e);if(s)return{x:a,y:u};if(l!==u)throw new Error("invZ was invalid");return{x:c,y:d}}),E=(0,n.x)(t=>{const{a:e,d:r}=l;if(t.is0())throw new Error("bad point: ZERO");const{X:n,Y:i,Z:s,T:o}=t,a=y(n*n),u=y(i*i),c=y(s*s),h=y(c*c),d=y(a*e);if(y(c*y(d+u))!==y(h+y(r*y(a*u))))throw new Error("bad point: equation left != right (1)");if(y(n*i)!==y(s*o))throw new Error("bad point: equation left != right (2)");return!0});class x{constructor(t,e,r,n){this.X=g("x",t),this.Y=g("y",e),this.Z=g("z",r,!0),this.T=g("t",n),Object.freeze(this)}static CURVE(){return l}static fromAffine(t){if(t instanceof x)throw new Error("extended point not allowed");const{x:e,y:r}=t||{};return g("x",e),g("y",r),new x(e,r,u,y(e*r))}static fromBytes(t,e=!1){const r=o.BYTES,{a:i,d:s}=l;t=(0,n.nC)((0,n.eV)(t,r,"point")),(0,n.d6)(e,"zip215");const c=(0,n.nC)(t),h=t[r-1];c[r-1]=-129&h;const d=(0,n.lX)(c),f=e?p:o.ORDER;(0,n.aK)("point.y",d,a,f);const g=y(d*d),w=y(g-u),B=y(s*g-i);let{isValid:E,value:S}=m(w,B);if(!E)throw new Error("bad point: invalid y coordinate");const v=(S&u)===u,b=!!(128&h);if(!e&&S===a&&b)throw new Error("bad point: x=0 and x_0=1");return b!==v&&(S=y(-S)),x.fromAffine({x:S,y:d})}static fromHex(t,e=!1){return x.fromBytes((0,n.qj)("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return S.createCache(this,t),e||this.multiply(c),this}assertValidity(){E(this)}equals(t){w(t);const{X:e,Y:r,Z:n}=this,{X:i,Y:s,Z:o}=t,a=y(e*o),u=y(i*n),c=y(r*o),h=y(s*n);return a===u&&c===h}is0(){return this.equals(x.ZERO)}negate(){return new x(y(-this.X),this.Y,this.Z,y(-this.T))}double(){const{a:t}=l,{X:e,Y:r,Z:n}=this,i=y(e*e),s=y(r*r),o=y(c*y(n*n)),a=y(t*i),u=e+r,h=y(y(u*u)-i-s),d=a+s,f=d-o,p=a-s,m=y(h*f),g=y(d*p),w=y(h*p),B=y(f*d);return new x(m,g,B,w)}add(t){w(t);const{a:e,d:r}=l,{X:n,Y:i,Z:s,T:o}=this,{X:a,Y:u,Z:c,T:h}=t,d=y(n*a),f=y(i*u),p=y(o*r*h),m=y(s*c),g=y((n+i)*(a+u)-d-f),B=m-p,E=m+p,S=y(f-e*d),v=y(g*B),b=y(E*S),A=y(g*S),T=y(B*E);return new x(v,b,T,A)}subtract(t){return this.add(t.negate())}multiply(t){if(!d.isValidNot0(t))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f:r}=S.cached(this,t,t=>(0,s.Ak)(x,t));return(0,s.Ak)(x,[e,r])[0]}multiplyUnsafe(t,e=x.ZERO){if(!d.isValid(t))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return t===a?x.ZERO:this.is0()||t===u?this:S.unsafe(this,t,t=>(0,s.Ak)(x,t),e)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}isTorsionFree(){return S.unsafe(this,l.n).is0()}toAffine(t){return B(this,t)}clearCofactor(){return f===u?this:this.multiplyUnsafe(f)}toBytes(){const{x:t,y:e}=this.toAffine(),r=o.toBytes(e);return r[r.length-1]|=t&u?128:0,r}toHex(){return(0,i.My)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return(0,s.Ak)(x,t)}static msm(t,e){return(0,s.Xf)(x,d,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}x.BASE=new x(l.Gx,l.Gy,u,y(l.Gx*l.Gy)),x.ZERO=new x(a,u,u,a),x.Fp=o,x.Fn=d;const S=new s.hT(x,d.BITS);return x.BASE.precompute(8),x}class l{constructor(t){this.ep=t}static fromBytes(t){(0,n.SJ)()}static fromHex(t){(0,n.SJ)()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(t){return this.ep.toAffine(t)}toHex(){return(0,i.My)(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(t){return this.assertSame(t),this.init(this.ep.add(t.ep))}subtract(t){return this.assertSame(t),this.init(this.ep.subtract(t.ep))}multiply(t){return this.init(this.ep.multiply(t))}multiplyUnsafe(t){return this.init(this.ep.multiplyUnsafe(t))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(t,e){return this.init(this.ep.precompute(t,e))}toRawBytes(){return this.toBytes()}}function f(t){const{CURVE:e,curveOpts:r,hash:s,eddsaOpts:a}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r={Fp:t.Fp,Fn:(0,o.D0)(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},n={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:r,hash:t.hash,eddsaOpts:n}}(t);return function(t,e){const r=e.Point;return Object.assign({},e,{ExtendedPoint:r,CURVE:t,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(t,function(t,e,r={}){if("function"!=typeof e)throw new Error('"hash" function param is required');(0,n.DS)(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:s}=r,{BASE:o,Fp:a,Fn:c}=t,h=r.randomBytes||i.po,d=r.adjustScalarBytes||(t=>t),l=r.domain||((t,e,r)=>{if((0,n.d6)(r,"phflag"),e.length||r)throw new Error("Contexts/pre-hash are not supported");return t});function f(t){return c.create((0,n.lX)(t))}function p(t){const{head:r,prefix:i,scalar:s}=function(t){const r=B.secretKey;t=(0,n.qj)("private key",t,r);const i=(0,n.qj)("hashed private key",e(t),2*r),s=d(i.slice(0,r));return{head:s,prefix:i.slice(r,2*r),scalar:f(s)}}(t),a=o.multiply(s),u=a.toBytes();return{head:r,prefix:i,scalar:s,point:a,pointBytes:u}}function y(t){return p(t).pointBytes}function m(t=Uint8Array.of(),...r){const o=(0,i.Id)(...r);return f(e(l(o,(0,n.qj)("context",t),!!s)))}const g={zip215:!0},w=a.BYTES,B={secretKey:w,publicKey:w,signature:2*w,seed:w};function E(t=h(B.seed)){return(0,n.eV)(t,B.seed,"seed")}const x={getExtendedPublicKey:p,randomSecretKey:E,isValidSecretKey:function(t){return(0,i.aY)(t)&&t.length===c.BYTES},isValidPublicKey:function(e,r){try{return!!t.fromBytes(e,r)}catch(t){return!1}},toMontgomery(e){const{y:r}=t.fromBytes(e),n=B.publicKey,i=32===n;if(!i&&57!==n)throw new Error("only defined for 25519 and 448");const s=i?a.div(u+r,u-r):a.div(r-u,r+u);return a.toBytes(s)},toMontgomerySecret(t){const r=B.secretKey;(0,n.eV)(t,r);const i=e(t.subarray(0,r));return d(i).subarray(0,r)},randomPrivateKey:E,precompute:(e=8,r=t.BASE)=>r.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=x.randomSecretKey(t);return{secretKey:e,publicKey:y(e)}},getPublicKey:y,sign:function(t,e,r={}){t=(0,n.qj)("message",t),s&&(t=s(t));const{prefix:a,scalar:u,pointBytes:h}=p(e),d=m(r.context,a,t),l=o.multiply(d).toBytes(),f=m(r.context,l,h,t),y=c.create(d+f*u);if(!c.isValid(y))throw new Error("sign failed: invalid s");const g=(0,i.Id)(l,c.toBytes(y));return(0,n.eV)(g,B.signature,"result")},verify:function(e,r,i,a=g){const{context:u,zip215:c}=a,h=B.signature;e=(0,n.qj)("signature",e,h),r=(0,n.qj)("message",r),i=(0,n.qj)("publicKey",i,B.publicKey),void 0!==c&&(0,n.d6)(c,"zip215"),s&&(r=s(r));const d=h/2,l=e.subarray(0,d),f=(0,n.lX)(e.subarray(d,h));let p,y,w;try{p=t.fromBytes(i,c),y=t.fromBytes(l,c),w=o.multiplyUnsafe(f)}catch(t){return!1}if(!c&&p.isSmallOrder())return!1;const E=m(u,y.toBytes(),p.toBytes(),r);return y.add(p.multiplyUnsafe(E)).subtract(w).clearCofactor().is0()},utils:x,Point:t,lengths:B})}(d(e,r),s,a))}}}]);