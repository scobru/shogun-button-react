/*! For license information please see 195.index.js.LICENSE.txt */
export const __webpack_esm_id__=195;export const __webpack_esm_ids__=[195];export const __webpack_esm_modules__={7766:(t,e,r)=>{r.d(e,{Tq:()=>u,qX:()=>d,zc:()=>c});var n=r(32531);function i(t,e){if(o(t),o(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function s(t,e){const r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function o(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function a(t){if(!(0,n.aY)(t)&&"string"!=typeof t)throw new Error("DST must be Uint8Array or string");return"string"==typeof t?(0,n.AI)(t):t}function u(t,e,r,u){(0,n.DO)(t),o(r),(e=a(e)).length>255&&(e=u((0,n.Id)((0,n.AI)("H2C-OVERSIZE-DST-"),e)));const{outputLen:c,blockLen:d}=u,h=Math.ceil(r/c);if(r>65535||h>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,n.Id)(e,i(e.length,1)),f=i(0,d),p=i(r,2),y=new Array(h),m=u((0,n.Id)(f,t,p,i(0,1),l));y[0]=u((0,n.Id)(m,i(1,1),l));for(let t=1;t<=h;t++){const e=[s(m,y[t-1]),i(t+1,1),l];y[t]=u((0,n.Id)(...e))}return(0,n.Id)(...y).slice(0,r)}function c(t,e,r,s,u){if((0,n.DO)(t),o(r),(e=a(e)).length>255){const t=Math.ceil(2*s/8);e=u.create({dkLen:t}).update((0,n.AI)("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return u.create({dkLen:r}).update(t).update(i(r,2)).update(e).update(i(e.length,1)).digest()}const d=(0,n.AI)("HashToScalar-")},26618:(t,e,r)=>{r.d(e,{TO:()=>h,i5:()=>l,n6:()=>f});var n=r(78906),i=r(32531),s=r(50649),o=r(15916);const a=BigInt(0),u=BigInt(1),c=BigInt(2),d=BigInt(8);function h(t,e={}){const r=(0,s.UT)("edwards",t,e,e.FpFnLE),{Fp:o,Fn:h}=r;let l=r.CURVE;const{h:f}=l;(0,n.DS)(e,{},{uvRatio:"function"});const p=c<<BigInt(8*h.BYTES)-u,y=t=>o.create(t),m=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:o.sqrt(o.div(t,e))}}catch(t){return{isValid:!1,value:a}}});if(!function(t,e,r,n){const i=t.sqr(r),s=t.sqr(n),o=t.add(t.mul(e.a,i),s),a=t.add(t.ONE,t.mul(e.d,t.mul(i,s)));return t.eql(o,a)}(o,l,l.Gx,l.Gy))throw new Error("bad curve params: generator point");function g(t,e,r=!1){const i=r?u:a;return(0,n.aK)("coordinate "+t,e,i,p),e}function w(t){if(!(t instanceof E))throw new Error("ExtendedPoint expected")}const B=(0,n.x)((t,e)=>{const{X:r,Y:n,Z:i}=t,s=t.is0();null==e&&(e=s?d:o.inv(i));const c=y(r*e),h=y(n*e),l=o.mul(i,e);if(s)return{x:a,y:u};if(l!==u)throw new Error("invZ was invalid");return{x:c,y:h}}),x=(0,n.x)(t=>{const{a:e,d:r}=l;if(t.is0())throw new Error("bad point: ZERO");const{X:n,Y:i,Z:s,T:o}=t,a=y(n*n),u=y(i*i),c=y(s*s),d=y(c*c),h=y(a*e);if(y(c*y(h+u))!==y(d+y(r*y(a*u))))throw new Error("bad point: equation left != right (1)");if(y(n*i)!==y(s*o))throw new Error("bad point: equation left != right (2)");return!0});class E{constructor(t,e,r,n){this.X=g("x",t),this.Y=g("y",e),this.Z=g("z",r,!0),this.T=g("t",n),Object.freeze(this)}static CURVE(){return l}static fromAffine(t){if(t instanceof E)throw new Error("extended point not allowed");const{x:e,y:r}=t||{};return g("x",e),g("y",r),new E(e,r,u,y(e*r))}static fromBytes(t,e=!1){const r=o.BYTES,{a:i,d:s}=l;t=(0,n.nC)((0,n.eV)(t,r,"point")),(0,n.d6)(e,"zip215");const c=(0,n.nC)(t),d=t[r-1];c[r-1]=-129&d;const h=(0,n.lX)(c),f=e?p:o.ORDER;(0,n.aK)("point.y",h,a,f);const g=y(h*h),w=y(g-u),B=y(s*g-i);let{isValid:x,value:S}=m(w,B);if(!x)throw new Error("bad point: invalid y coordinate");const b=(S&u)===u,v=!!(128&d);if(!e&&S===a&&v)throw new Error("bad point: x=0 and x_0=1");return v!==b&&(S=y(-S)),E.fromAffine({x:S,y:h})}static fromHex(t,e=!1){return E.fromBytes((0,n.qj)("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return S.createCache(this,t),e||this.multiply(c),this}assertValidity(){x(this)}equals(t){w(t);const{X:e,Y:r,Z:n}=this,{X:i,Y:s,Z:o}=t,a=y(e*o),u=y(i*n),c=y(r*o),d=y(s*n);return a===u&&c===d}is0(){return this.equals(E.ZERO)}negate(){return new E(y(-this.X),this.Y,this.Z,y(-this.T))}double(){const{a:t}=l,{X:e,Y:r,Z:n}=this,i=y(e*e),s=y(r*r),o=y(c*y(n*n)),a=y(t*i),u=e+r,d=y(y(u*u)-i-s),h=a+s,f=h-o,p=a-s,m=y(d*f),g=y(h*p),w=y(d*p),B=y(f*h);return new E(m,g,B,w)}add(t){w(t);const{a:e,d:r}=l,{X:n,Y:i,Z:s,T:o}=this,{X:a,Y:u,Z:c,T:d}=t,h=y(n*a),f=y(i*u),p=y(o*r*d),m=y(s*c),g=y((n+i)*(a+u)-h-f),B=m-p,x=m+p,S=y(f-e*h),b=y(g*B),v=y(x*S),A=y(g*S),T=y(B*x);return new E(b,v,T,A)}subtract(t){return this.add(t.negate())}multiply(t){if(!h.isValidNot0(t))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f:r}=S.cached(this,t,t=>(0,s.Ak)(E,t));return(0,s.Ak)(E,[e,r])[0]}multiplyUnsafe(t,e=E.ZERO){if(!h.isValid(t))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return t===a?E.ZERO:this.is0()||t===u?this:S.unsafe(this,t,t=>(0,s.Ak)(E,t),e)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}isTorsionFree(){return S.unsafe(this,l.n).is0()}toAffine(t){return B(this,t)}clearCofactor(){return f===u?this:this.multiplyUnsafe(f)}toBytes(){const{x:t,y:e}=this.toAffine(),r=o.toBytes(e);return r[r.length-1]|=t&u?128:0,r}toHex(){return(0,i.My)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return(0,s.Ak)(E,t)}static msm(t,e){return(0,s.Xf)(E,h,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}E.BASE=new E(l.Gx,l.Gy,u,y(l.Gx*l.Gy)),E.ZERO=new E(a,u,u,a),E.Fp=o,E.Fn=h;const S=new s.hT(E,h.BITS);return E.BASE.precompute(8),E}class l{constructor(t){this.ep=t}static fromBytes(t){(0,n.SJ)()}static fromHex(t){(0,n.SJ)()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(t){return this.ep.toAffine(t)}toHex(){return(0,i.My)(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(t){return this.assertSame(t),this.init(this.ep.add(t.ep))}subtract(t){return this.assertSame(t),this.init(this.ep.subtract(t.ep))}multiply(t){return this.init(this.ep.multiply(t))}multiplyUnsafe(t){return this.init(this.ep.multiplyUnsafe(t))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(t,e){return this.init(this.ep.precompute(t,e))}toRawBytes(){return this.toBytes()}}function f(t){const{CURVE:e,curveOpts:r,hash:s,eddsaOpts:a}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r={Fp:t.Fp,Fn:(0,o.D0)(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},n={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:r,hash:t.hash,eddsaOpts:n}}(t);return function(t,e){const r=e.Point;return Object.assign({},e,{ExtendedPoint:r,CURVE:t,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(t,function(t,e,r={}){if("function"!=typeof e)throw new Error('"hash" function param is required');(0,n.DS)(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:s}=r,{BASE:o,Fp:a,Fn:c}=t,d=r.randomBytes||i.po,h=r.adjustScalarBytes||(t=>t),l=r.domain||((t,e,r)=>{if((0,n.d6)(r,"phflag"),e.length||r)throw new Error("Contexts/pre-hash are not supported");return t});function f(t){return c.create((0,n.lX)(t))}function p(t){const{head:r,prefix:i,scalar:s}=function(t){const r=B.secretKey;t=(0,n.qj)("private key",t,r);const i=(0,n.qj)("hashed private key",e(t),2*r),s=h(i.slice(0,r));return{head:s,prefix:i.slice(r,2*r),scalar:f(s)}}(t),a=o.multiply(s),u=a.toBytes();return{head:r,prefix:i,scalar:s,point:a,pointBytes:u}}function y(t){return p(t).pointBytes}function m(t=Uint8Array.of(),...r){const o=(0,i.Id)(...r);return f(e(l(o,(0,n.qj)("context",t),!!s)))}const g={zip215:!0},w=a.BYTES,B={secretKey:w,publicKey:w,signature:2*w,seed:w};function x(t=d(B.seed)){return(0,n.eV)(t,B.seed,"seed")}const E={getExtendedPublicKey:p,randomSecretKey:x,isValidSecretKey:function(t){return(0,i.aY)(t)&&t.length===c.BYTES},isValidPublicKey:function(e,r){try{return!!t.fromBytes(e,r)}catch(t){return!1}},toMontgomery(e){const{y:r}=t.fromBytes(e),n=B.publicKey,i=32===n;if(!i&&57!==n)throw new Error("only defined for 25519 and 448");const s=i?a.div(u+r,u-r):a.div(r-u,r+u);return a.toBytes(s)},toMontgomerySecret(t){const r=B.secretKey;(0,n.eV)(t,r);const i=e(t.subarray(0,r));return h(i).subarray(0,r)},randomPrivateKey:x,precompute:(e=8,r=t.BASE)=>r.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=E.randomSecretKey(t);return{secretKey:e,publicKey:y(e)}},getPublicKey:y,sign:function(t,e,r={}){t=(0,n.qj)("message",t),s&&(t=s(t));const{prefix:a,scalar:u,pointBytes:d}=p(e),h=m(r.context,a,t),l=o.multiply(h).toBytes(),f=m(r.context,l,d,t),y=c.create(h+f*u);if(!c.isValid(y))throw new Error("sign failed: invalid s");const g=(0,i.Id)(l,c.toBytes(y));return(0,n.eV)(g,B.signature,"result")},verify:function(e,r,i,a=g){const{context:u,zip215:c}=a,d=B.signature;e=(0,n.qj)("signature",e,d),r=(0,n.qj)("message",r),i=(0,n.qj)("publicKey",i,B.publicKey),void 0!==c&&(0,n.d6)(c,"zip215"),s&&(r=s(r));const h=d/2,l=e.subarray(0,h),f=(0,n.lX)(e.subarray(h,d));let p,y,w;try{p=t.fromBytes(i,c),y=t.fromBytes(l,c),w=o.multiplyUnsafe(f)}catch(t){return!1}if(!c&&p.isSmallOrder())return!1;const x=m(u,y.toBytes(),p.toBytes(),r);return y.add(p.multiplyUnsafe(x)).subtract(w).clearCofactor().is0()},utils:E,Point:t,lengths:B})}(h(e,r),s,a))}}};